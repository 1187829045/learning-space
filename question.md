# 面试题

## 1.如果在CDN中，源站发起了一个更新，如何让远端和近端的人同时拿到更新，而不是拿到旧的缓存？
1. 主动刷新缓存
2. 在资源链接上加入唯一标识参数,然后CDN会视为新资源
3. 预热与监控闭环:更新后提交预热任务，提前将新内容加载至CDN边缘节点，避免首用户访问延迟。


## 2.网络协议的定义是啥，说一说网络协议的三个要素
网络协议是计算机网络中实现数据交换的规则、标准或约定的集合，相当于不同设备间的"通信语言"。它通过统一的交互规则，解决不同终端设备（如计算机、路由器等）在硬件架构、操作系统差异下的互联互通问题。
#### 网络协议三要素 
1. 语义:例如：HTTP协议中状态码200表示请求成功，404代表资源未找到
2. 语法：规定数据传输的结构与格式,数据包头部/尾部字段的二进制排列规则,字符编码标准（如HTTP报文采用UTF-8编码）
3. 时序 : 控制通信流程的顺序与节奏,握手协议（如TCP三次握手建立连接,超时重传机制


## 3.解释一下哈希算法

哈希算法是一种将任意长度输入数据映射为固定长度输出的密码学工具，其核心功能是生成具有唯一性标识的「数字指纹」。
1. 核心特性 :确定性,不可逆性,抗碰撞性,雪崩效应(输入微小变化导致输出显著不同。例如，将"Hello"改为"hello"，其哈希值差异超过90%的二进制位)
2. 以SHA-256为例：将输入数据切分为512位的数据块。使用8个固定32位常数（如6A09E667、BB67AE85等）作为初始哈希值。对每块数据进行64轮逻辑运算（如位运算、模加运算），更新中间哈希值。最终拼接8个中间值得到256位哈希。

## 4.如何设计session
1. 存储截止选型:内存数据库(读写速度快（微秒级响应），支持TTL自动过期),关系型数据库(优势：事务支持强，适合复杂查询场景)
2. 数据结构的话,JSON序列化数据,字段建议：用户ID、登录时间、最后活跃时间、自定义属性


## 5.http和rpc的区别
HTTP 协议与 RPC 的核心区别体现在协议设计目标、性能优化、适用场景三个维度。以下是具体对比分析：

1. 本质定位与协议设计:http是应用层协议,rpc远程调用机制,需通过具体协议（如 gRPC、Dubbo）实现，定义调用方式与流程,http浏览器和服务器的交互,rpc主要是高性能,低延迟
http有固定报文结构（Header+Body），必须遵循规范（如 GET/POST 方法）,rpc可定制协议（如 TCP 私有协议、HTTP/2 二进制封装），支持自定义序列化与压缩.
2. 性能与效率对比:http,文本格式（JSON/XML）为主，体积大，解析慢,rpc二进制协议（Protobuf、Thrift）为主，体积小，编解码效率高
3. 应用场景与功能特性 : http是应用层协议，主要处理客户端与服务器之间的请求和响应，通常用于客户端与服务器之间的通信，如Web请求、文件传输等。而RPC是网络通信协议，主要用于分布式系统之间的通信，通常用于远程过程调用（Remote Procedure Call）等场景。

## 6.两者如何选择

优先选择 HTTP 的场景：
1. 需跨语言、跨平台（如第三方 API 对接）
2. 数据传输以文本为主（如 Web 页面渲染）
3. 对性能要求不敏感（低频调用或小数据量）

优先选择 RPC 的场景：
1. 高并发、低延迟的内部服务通信（如电商订单系统）
2. 需要服务治理能力（如自动熔断、链路追踪）
3. 定制化协议优化（如金融系统要求毫秒级响应）

## 7.如何确保redis同步mysql时，最新的信息不丢失？答了AOF，说AOF在写入前的瞬间挂掉了怎么办？
为确保 Redis 与 MySQL 同步时最新数据不丢失，需从数据更新策略、可靠性传输、持久化机制、异常处理四个维度构建完整解决方案
1. 写操作优先保证数据库一致性:所有写操作 先更新 MySQL，再处理 Redis，避免缓存与数据库的“双写不一致”。Cache-Aside Pattern（旁路缓存模式）
2. 同步机制选择:关键数据：订阅 MySQL Binlog + 同步更新 Redis（如通过 Canal 监听）,普通数据：延迟双删策略（两次删除缓存，间隔主从延迟时间）

## 8.什么是延迟双删

延迟双删是一种用于解决 缓存（如 Redis）与数据库（如 MySQL）数据一致性 问题的策略，尤其在高并发场景下，能有效减少因并发读写导致的数据不一致时间窗口。其核心思想是通过 两次删除缓存并结合延迟等待，确保缓存中的旧数据被彻底清理。
1. 第一次删除缓存,在更新数据库 之前，先删除缓存中的旧数据，确保后续的读请求不会命中旧缓存。
2. 更新数据库,执行数据库写操作（如 SQL 的 UPDATE 或 INSERT）。
3. 延迟等待,等待一个 合理的时间间隔（通常根据 MySQL 主从同步延迟估算，如 500ms~1s），确保数据库主从同步完成。
4. 第二次删除缓存,延迟结束后，再次删除缓存，清除可能因并发读操作重新写入的旧数据。


## 9.什么是binlog和Redo Log,分别的作用是什么
Binlog（二进制日志）和 Redo Log（重做日志）是 MySQL 中两种关键日志机制，分别承担不同功能，共同保障数据库的数据一致性与可靠性.

1. Binlog 是mysql的server层实现的,与存储引擎无关,日志类型：逻辑日志，记录 SQL 语句的原始逻辑（如 UPDATE users SET name='Alice' WHERE id=1;）或行数据变化（ROW 格式）.

**_核心作用_**：主从复制：从库通过重放主库的 binlog 实现数据同步。数据恢复：结合全量备份与 binlog 增量日志，可将数据库恢复到任意时间点。

_写入规则：_ 事务提交时一次性写入（受 sync_binlog 参数控制刷盘策略）。文件以追加方式存储，不会覆盖旧日志（按时间或大小滚动归档）。

_***日志格式：***_ STATEMENT：记录 SQL 原文（可能因函数导致主从不一致）。ROW（推荐）：记录每行数据的变化细节（保证一致性）。MIXED：混合模式，自动选择逻辑或行格式。

2.  Redo Log（重做日志）:由 InnoDB 存储引擎实现，专用于事务的持久性和崩溃恢复,物理日志，记录数据页的物理修改（如页号、偏移量、修改后的值）

**_核心作用：_** 崩溃恢复：系统宕机后，通过重放未刷盘的 redo log 恢复已提交事务的数据。提升性能：采用 WAL（预写日志）机制，事务提交时只需写日志，无需立即刷脏页到磁盘。

**_写入规则：_** 事务执行中实时写入内存（redo log buffer），提交时刷盘（受 innodb_flush_log_at_trx_commit 控制）。固定大小循环写入（默认 ib_logfile0 和 ib_logfile1），覆盖旧日志


## 10.主键索引和普通索引的区别
1. 唯一性:主键索引强制唯一,不允许重复和空置,普通索引允许重复值和空值
2. 数量限制:每个表只能有一个主键索引,可以有多个普通索引
3. 索引类型:主键索引是聚集索引,普通索引是非聚集
4. 自动创建:主键索引会自动创建,需显式通过CREATE INDEX语句或建表时指定
5. 物理存储顺序:数据行按主键值顺序存储，直接影响数据页的物理排列,普通索引,仅索引列按顺序存储，不影响数据行的物理位置
6. 查询效率:主键索引,单次查找，时间复杂度O(logN)，适用于主键精确查询。普通索引：两次查找（普通索引+主键索引），时间复杂度接近2*O(logN)，存在回表开销。
7. 覆盖索引优化:若查询字段全部包含在普通索引中（如联合索引(name, age)查询SELECT name, age），可避免回表，性能接近主键索引。
8. 插入/更新:主键索引:可能触发页分裂（数据页按主键顺序存储，插入中间值需重排数据）,普通索引,仅需更新索引树，不影响数据页物理顺序
9. 删除:主键索引,删除主键行时，需同时清理数据和索引结构	普通索引:仅需删除索引条目，数据行保留（除非级联删除）
10. 存储空间	主键索引:索引与数据合并存储，空间占用更高效	,普通索引：需额外存储主键值（用于回表），空间占用较高
11. 主键索引适用场景,1.需要唯一标识每行数据（如用户ID、订单号）。2.高频通过单一字段查询整行数据的场景（如用户详情页）。3.需要作为外键引用的字段（确保关联查询效率）。
12. 普通索引适用场景,1.高频查询非主键字段（如根据姓名、手机号检索）。2.联合索引优化多条件查询（如(city, age)组合查询）。3.需要允许重复值的字段（如商品分类、标签）。


## 11.多路复用
在计算机系统中，IO多路复用允许单线程管理多个网络连接或文件描述符

1. select/poll：轮询检查文件描述符状态，效率较低。
2. epoll（Linux）：基于事件驱动，仅关注活跃连接，性能更高。


## 12.内核态和用户态的一个区别，为什么设计这两种模式？

1. 核心区别：权限与资源访问能力,内核态:CPU 执行最高特权指令（如 x86 的 Ring 0 级），可直接操作硬件（如磁盘、网卡）、管理内存分配、修改进程调度表等核心资源 ,
用户态:CPU 执行受限指令（如 x86 的 Ring 3 级），无法直接访问硬件或修改系统关键数据。仅能访问进程自身的虚拟内存空间（通过页表隔离），需通过系统调用请求内核服务。
2. 设计原因：安全、稳定与资源管理 ,防止恶意程序破坏系统：若用户程序能直接操作硬件（如修改内存管理单元），可能导致系统崩溃或被恶意攻击（如修改内核代码）。
提升系统稳定性：用户程序可能存在逻辑错误（如空指针访问），若运行在内核态会直接导致系统崩溃。
高效管理硬件资源：内核统一调度 CPU、内存等资源，避免多个程序竞争导致混乱（如两个进程同时写入同一磁盘区域）。



## 13.怎么评估数据库表中一个索引是否创建的合理？
1. 列的离散度（Distinctiveness）,离散度越高，索引筛选效率越高。例如性别字段（仅2种值）离散度低，不适合单独索引；用户ID（唯一值）离散度高，适合索引
2. 高频查询字段:频繁出现在 WHERE、JOIN、ORDER BY、GROUP BY 中的字段优先索引。
3. 避免冗余索引:检查是否存在功能重叠的索引（如已有 (a,b) 联合索引，单独索引 a 可能冗余）。

## 14.解释go中的反射，有什么作用？

1. 反射的基本原理 -接口与类型系统

Go的接口（interface{}）存储了变量的动态类型（_type）和动态值（data），反射通过解析接口的这两部分信息实现动态操作。

空接口（无方法）和有方法的接口均通过类型描述符（_type）和值指针描述数据。

示例：reflect.TypeOf() 获取类型信息，reflect.ValueOf() 获取值信息。

2. 核心类型

reflect.Type：描述类型元信息（如字段、方法、包路径等）。

reflect.Value：封装变量的值，支持修改值、调用方法等操作。

#### 15.反射的核心作用
1. 动态类型检查与操作 :运行时获取变量类型,动态修改变量值

```go
   v := reflect.ValueOf(&x).Elem()
   v.SetInt(42) // 修改 x 的值为 42
```
2. 处理未知类型的数据,用函数与框架：如 fmt.Println 能打印任意类型数据，JSON 序列化库 encoding/json 通过反射解析结构体标签。

3. 动态调用方法：通过 MethodByName() 调用结构体的方法。

4. 适用场景包括框架开发、数据序列化、动态调用等，普通业务逻辑中应谨慎使用。


## 16. 如何设计一个高并发计数器服务，考虑数据一致性，和性能优化？

写流程：客户端 → Redis INCR → Kafka 批量消息 → MySQL 异步落盘（每10秒或积累1000条触发）

读流程：客户端 → Redis 实时值（最新计数） → 降级策略（Redis不可用 → 查询MySQL+补偿）

## 17. 网络I/O的同步和异步的差别

1. 执行逻辑: 同步IO:进程发起I/O请求后必须等待操作完成，期间无法执行其他任务（如调用read()后阻塞）,异步 IO:进程发起I/O请求后立即返回，继续处理后续任务，内核完成操作后通过事件/回调通知
2. 数据阶段:同步IO:包含两个阶段：等待数据就绪（内核态）和拷贝数据到用户空间（用户态），均需等待 异步 IO:内核完成所有操作（包括数据拷贝），仅通过一次通知告知进程结果
3. 时序性:同步IO:严格按请求顺序执行，保证操作原子性,异步IO请求与完成无严格时序关系，可能并发处理多个I/O
4. 资源占用:同步IO:线程/进程在等待期间被挂起，占用内存但CPU闲置,异步IO:仅需少量线程即可处理大量I/O，CPU利用率高


## 18.TCP通过哪些方式实现可靠性
1. 校验和（Checksum）作用：检测数据在传输过程中是否损坏或篡改。
2. 序列号与确认应答（Sequence & ACK）,序列号,确认号
3. 超时重传（Retransmission）
4. 滑动窗口（Sliding Window）
5. 快速重传（Fast Retransmit）
6. 流量控制（Flow Control）
7. 拥塞控制（Congestion Control）
8. 三次握手建立连接
9. 四次挥手释放连接

## 19.内存泄漏原理,怎么排查以及怎么解决
内存泄漏（Memory Leak）指程序未能释放不再使用的内存，导致内存占用持续增长，最终可能引发 OOM（Out of Memory） 或性能下降。在 Golang 中，虽然具备自动垃圾回收（GC），但编码不当仍会导致泄漏。

####  核心原因

1. 引用未释放：对象被全局变量、长生命周期结构（如缓存）或未关闭的 Goroutine 引用，GC 无法回收。
2. 资源未关闭：文件句柄、网络连接、数据库连接、time.Ticker 未释放。
#### 排查方法

1. 监控工具,runtime 包：监控内存和 Goroutine 数量。
```shell
  // 实时打印内存和 Goroutine 状态
  go func() {
      for {
          var m runtime.MemStats
          runtime.ReadMemStats(&m)
          fmt.Printf("Alloc = %v MiB, Goroutines = %d\n", m.Alloc/1024/1024, runtime.NumGoroutine())
          time.Sleep(5 * time.Second)
      }
  }()
```
2. pprof 分析
   启用 pprof：
```shell
   import _ "net/http/pprof"
   go func() { http.ListenAndServe("0.0.0.0:6060", nil) }() 
```

生成报告：
```shell
 查看堆内存
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/heap
查看 Goroutine 栈
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

## 20.go的context在高并发下有什么问题
在 Go 的高并发场景中，context 是管理协程生命周期和数据传递的核心工具，但若使用不当会引发 资源泄漏、性能瓶颈、数据竞争 等问题

1. Context 未正确取消导致 Goroutine 泄漏
```shell
   问题：父 Context 取消后，子 Goroutine 未监听 ctx.Done()，导致无法退出。
   go func() {
      // 未监听 ctx.Done()，即使父 Context 取消也无法退出
      processTask()
  }()
   影响：高并发下积累大量僵尸 Goroutine，内存占用飙升，最终 OOM
   案例：HTTP 服务未绑定请求 Context，客户端断开后处理协程仍运行
```

2. 超时控制失效引发级联故障
```shell
   问题：未设置超时或超时时间不合理，导致请求堆积。
   // 未设置超时,阻塞操作可能无限等待
   ctx := context.Background()
   result, err := db.Query(ctx, "SELECT * FROM large_table")
   影响：数据库连接池耗尽，服务雪崩。 
   案例：微服务链路中某环节超时未传递，下游服务持续等待。
```


3. Context 值传递引发竞争或性能问题
```shell
   问题：滥用 context.WithValue 存储大对象或频繁访问数据。
   // 存储大对象，增加内存压力
   ctx := context.WithValue(parentCtx, "data", largeData)
   影响：高并发下内存占用高，频繁读写引发竞争（需配合锁）。 
```

4. 重复取消或多次调用 CancelFunc
```shell
   问题：多次调用 cancel() 导致 Channel 重复关闭，触发 Panic。
   ctx, cancel := context.WithCancel(context.Background())
   go func() { cancel() }()
   go func() { cancel() }() // 可能重复调用 
```


## 21.go的gorm底层是否有连接池，是否有用过
有

```shell
  // 示例：配置连接池
  db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
  sqlDB, _ := db.DB()
  sqlDB.SetMaxOpenConns(100)  // 最大连接数
  sqlDB.SetMaxIdleConns(20)   // 最大空闲连接
  sqlDB.SetConnMaxLifetime(time.Hour) // 连接最大存活时间
```

## 22.go的gin框架的特点？还用过什么web框架
1. 极致性能 路由引擎：
基于 http router 的 Radix 树算法实现路由匹配，时间复杂度为 O(n)（路径长度），而非传统框架的 O(m)（路由数量），性能接近原生 net/http，基准测试 QPS 高达 40 万+。
低内存消耗：轻量级设计，内存占用仅为同类框架的 1/3~1/2，适合高并发场景（如 API 网关、微服务）

2. 简洁易用的 API
链式调用：通过 c.JSON()、c.String() 等封装方法直接处理响应，无需手动序列化或设置 Content-Type。
参数绑定与验证：支持自动解析请求参数到结构体，并集成数据验证（如字段必填、格式校验）。
3.  强大的中间件生态,内置中间件：默认集成日志（Logger）、崩溃恢复（Recovery）等常用功能。支持自定义中间件（如 JWT 鉴权、限流），社区提供数百种现成中间件



## 23.MySQL的事务隔离以及如何实现？

1. 读已提交 (RC): MVCC + 行锁，每次查询生成新 ReadView。
2. 可重复读 (RR):MVCC + Next-Key 锁，事务开始时生成唯一 ReadView。InnoDB 默认级别，已解决幻读。
3. 串行化:读写均加锁（读锁共享，写锁排他），完全串行化执行。

## 24.如何实现分布式锁
分布式锁是协调分布式系统中多个节点对共享资源互斥访问的核心技术，其实现需满足 互斥性、无死锁、容错性、高可用性 等要求

1. 基于数据库实现:悲观锁, 使用 SELECT ... FOR UPDATE 锁定记录，其他事务阻塞等待。优点：实现简单，依赖数据库事务。缺点：性能低（IO开销大），锁表风险高，需手动管理超时;乐观锁
利用版本号或时间戳实现 CAS,适用场景：低并发、短事务场景（如库存扣减）。
2. 基于 Redis 实现 : 基础方案（单节点）,使用 SETNX + 过期时间 + 唯一标识（UUID）.
```shell
  SET lock_key $uuid NX PX 30000  # 加锁（30秒自动释放）
  EVAL "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end" 1 lock_key $uuid  # 释放锁 
```
3. 基于 ZooKeeper 实现 临时顺序节点 + Watcher 监听

步骤：1.创建临时顺序节点 /locks/lock_00000001。2.检查是否最小节点，若是则获取锁。若非最小，监听前一个节点的删除事件。3.业务完成删除自身节点，触发后续节点获取锁。

优点：强一致性，自动释放（会话断开节点删除）。

缺点：性能低于 Redis，需维护 ZK 集群。


## 25.线程池底层，什么场景下使用
线程池通过 复用线程资源、控制并发规模、减少系统开销 提升程序性能
#### 底层
1. 线程池管理器（ThreadPoolExecutor）负责线程的创建、销毁和任务调度，通过参数动态控制线程池行为：

corePoolSize：核心线程数（常驻线程，即使空闲也不销毁）。

maximumPoolSize：最大线程数（临时线程，空闲超时后回收）。

workQueue：任务队列（缓冲未处理的任务）。

RejectedExecutionHandler：拒绝策略（队列满时的处理逻辑）。

2. 工作线程（Worker）
封装 Thread 和 Runnable 任务，循环从队列获取任务执行。

3. 任务队列（BlockingQueue）
存储待处理任务，常见类型：

无界队列（如 LinkedBlockingQueue）：适合任务量稳定但执行较慢的场景。

有界队列（如 ArrayBlockingQueue）：防止资源耗尽，需配合拒绝策略。

优先级队列（如 PriorityBlockingQueue）：按任务优先级调度。

#### 使用场景
1. 高并发请求处理
2. 批量异步任务


## 26.https的Tls rsa握手过程，存在什么安全隐患，分别怎么解决的
HTTPS 的 TLS RSA 握手过程虽然通过非对称加密实现了密钥协商

#### TLS RSA 握手流程回顾
以 TLS 1.2 为例的 RSA 握手关键步骤：
1. Client Hello：客户端发送支持的加密套件列表和随机数（Client Random）。
2. Server Hello：服务器选择 RSA 加密套件，返回证书、随机数（Server Random）。
3. Client Key Exchange：检查证书,客户端生成预主密钥（Pre-Master Secret），用服务器公钥加密后发送。
4. 生成会话密钥：客户端和服务器根据 Client Random、Server Random、Pre-Master 计算主密钥（Master Secret）和会话密钥
#### 安全隐患及解决方案
1. 前向安全性缺失:风险：若服务器私钥泄露，历史通信记录可被解密
2. 中间人攻击（MITM）风险


## 27.redis zset底层实现的数据结构
ZSet 有两种不同的实现，分别是 ziplist 和 skiplist

1. ziplist：满足以下两个条件：[value，score]键值对数量少于128个；每个元素的长度小于64字节。
2. skiplist：不满足以上两个条件时使用skiplist跳表，组合了hash和skiplist
   ,hash用来存储value到score的映射，在时间复杂度o(1)时间内知道对应value的分数。
   skiplist按照从小到大的顺序存储分数；每个元素存储的都是<value,score>对。

## 28.说一下MVCC
主要是依靠这两个东西来实现的:
1. Read View中四个字段作用;
2. 聚簇索引记录中两个跟事务有关的隐藏列；

#### Read View有四个重要的字段：
1. m_ids：指的是在创建ReadView时，当前数据库中「活跃事务」的事务id列表，”活跃事务”指的就是，启动了但还没提交的事务。
2. min_trx_id：指的是在创建Read View时，当前数据库中「活跃事务」中事务id最小的事务，也就是m_ids 的最小值。
3. max_trx_id：这个并不是m_ids的最大值，而是创建ReadView时当前数据库中应该给下一个事务的id值，也就是全局事务中最大的事务id值+1;
4. creator_trx_id：指的是创建该 Read View的事务的事务 id。
#### 两个隐藏列
1. trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务id记录在trx_id隐藏列里;
2. roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到undo日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。

如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值,可见

如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值,不可见

trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间,需要判断 trx_id 是否在 m_ids 列表中,在,不可见,不在,可见

## 29.什么是协程？
协程（Coroutine）是一种用户态的轻量级线程，通过 协作式调度 而非操作系统的抢占式调度来实现并发。其核心特点是 主动让出执行权 和 恢复上下文，适用于高并发、低延迟场景。

## 30.为什么有了线程之后还要有协程？
线程和协程在并发编程中各有优劣，协程的诞生并非替代线程，而是为了解决线程在高并发场景下的性能瓶颈和开发复杂性。

#### 线程的局限性
1. 高资源消耗
内存占用：每个线程需分配 1MB+ 的栈空间，1000 个线程即占用 1GB+ 内存,切换开销：线程切换涉及内核态与用户态转换，耗时约 1000ns
2. 并发规模受限
C10K 问题：万级线程会导致内存耗尽和调度延迟。竞争与锁开销：共享内存需频繁加锁，易引发死锁或性能下降。

#### 协程的核心优势
1. 极低资源消耗,轻量级栈：协程初始栈仅 2KB，单机可承载百万级并发。用户态调度：无需内核介入，切换仅保存寄存器状态（如 PC、SP），无上下文切换开销。
2. 协作式调度,主动让出控制权：协程在 IO 阻塞时主动挂起，线程立即执行其他协程，提升 CPU 利用率。

## 31.进程间的通信
1. 管道（Pipe）:匿名和有名
2. 消息队列
3. 共享内存
4. 信号量
5. 套接字
6. 信号
## 32.共享内存的原理，怎么创建

1. 共享内存的原理,多个进程将同一块物理内存映射到各自的虚拟地址空间，实现直接读写共享数据，无需内核中转，是速度最快的 IPC 方式。
2. 实现步骤,创建共享内存：通过系统调用分配一块物理内存（或映射文件到内存）。映射到进程空间：将共享内存附加到进程的虚拟地址空间。同步访问：使用信号量、互斥锁等机制避免竞态条件。
3. 优点与缺点,优点：零拷贝，性能极高（适合大数据频繁交互）。 缺点：需手动处理同步，编程复杂度高。

```go
// 1. 创建或打开共享内存标识符
	const size = unsafe.Sizeof(SharedData{})
	const key = 12345 // 共享内存唯一标识

	// 使用 shmget 创建共享内存段
	shmID, _, err := syscall.Syscall6(
		syscall.SYS_SHMGET,
		uintptr(key),
		uintptr(size),
		uintptr(0666|syscall.IPC_CREAT),
		0, 0, 0,
	)
	if err != 0 {
		panic("shmget failed: " + err.Error())
	}

	// 2. 映射共享内存到进程地址空间
	sharedMem, _, err := syscall.Syscall6(
		syscall.SYS_SHMAT,
		shmID,
		0,
		0,
		0, 0, 0,
	)
	if err != 0 {
		panic("shmat failed: " + err.Error())
	}
	defer syscall.Syscall(syscall.SYS_SHMDT, sharedMem, 0, 0)

	// 转换为数据结构指针
	data := (*SharedData)(unsafe.Pointer(sharedMem))

	// 3. 操作共享数据（需同步！）
	data.Counter++
	copy(data.Message[:], "Hello from Go")

	fmt.Printf("Counter: %d, Message: %s\n", data.Counter, string(data.Message[:]))
```
## 33.如何优雅地结束一个goroutine
1. Context 通知（官方推荐）
```shell
func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("收到退出信号，清理资源...")
            return
        default:
            // 执行任务（如处理消息队列）
            processTask()
        }
    }
}

// 主程序调用
ctx, cancel := context.WithCancel(context.Background())
go worker(ctx)
time.Sleep(5 * time.Second)
cancel() // 触发退出
```
2. Channel 信号通知

```shell
func worker(quitChan <-chan struct{}) {
    for {
        select {
        case <-quitChan:
            fmt.Println("退出指令接收，释放文件句柄...")
            return
        default:
            // 执行任务（如写入日志）
            writeLog()
        }
    }
}

// 主程序调用
quit := make(chan struct{})
go worker(quit)
close(quit) // 发送退出信号
```
3. Sync.WaitGroup 同步控制

```shell
func worker(wg *sync.WaitGroup, quitChan <-chan struct{}) {
    defer wg.Done()
    for {
        select {
        case <-quitChan:
            return
        default:
            // 执行任务（如处理数据库连接）
            handleDBQuery()
        }
    }
}

// 主程序调用
var wg sync.WaitGroup
quit := make(chan struct{})
wg.Add(3)
for i := 0; i < 3; i++ {
    go worker(&wg, quit)
}
close(quit) // 通知所有 worker 退出
wg.Wait()   // 阻塞至所有协程退出
```



## 34.B树和B+树分别介绍
####  B树（B-Tree）
1. 核心特点

多路平衡：每个节点最多有m 个子节点（m 阶B树），且所有叶子节点在同一层。

数据分布：所有节点（包括内部节点）均存储数据（键值对）。

键值排列：节点中的键按升序排列，用于导航子树。
#### B+树（B+ Tree）
1. 核心特点

数据分离：仅叶子节点存储数据，内部节点仅存键作为索引。

叶子链表：所有叶子节点通过指针连接成链表，支持高效范围查询。

键冗余：内部节点的键在叶子节点中重复出现（用于导航）。

## 35.浏览器输入 URL 的一个过程
1. URL 解析与预处理
2. DNS 域名解析
3. 网络连接建立
4. HTTP 请求与响应
5. 浏览器渲染引擎工作流

## 36.Golang 的 GMP 调度
#### GMP 的核心组件
1. G（Goroutine）：轻量级协程，初始栈约 2KB，动态伸缩。
2. M（Machine）：操作系统线程（OS Thread），负责执行代码，与内核线程一一对应。
3. P（Processor）：逻辑处理器，管理一组本地 Goroutine 队列（和线程绑定），数量由 GOMAXPROCS 决定（默认 CPU 核数）。

#### 调度器的工作流程
1. P 的分配：每个 M 必须绑定一个 P 才能执行 G。如果 M 被阻塞（如系统调用），P 会解绑并寻找空闲 M，或创建新 M（避免线程浪费）。
2. G 的执行：

本地队列：P 优先从自己的本地队列取 G 执行（无锁，高效）。

全局队列：本地队列为空时，从全局队列偷一批 G（分摊锁竞争）。

窃取机制（Work Stealing）：本地和全局队列都空时，从其他 P 的本地队列偷 G。

3. 阻塞处理：

若 G 发起系统调用（如文件 I/O），M 会阻塞，此时 P 会解绑并转去服务其他 M。

系统调用结束后，M 尝试获取 P，若失败则将 G 放回全局队列，自身休眠。

## 37.M 系统调用结束以后会怎么样

1. M 从内核态返回用户态:系统调用完成后，M 重新回到用户态，此时需要重新与调度器协作。

2. 尝试绑定空闲的 P: M 会优先尝试重新绑定 原来的 P（如果该 P 仍空闲）。若原 P 已被其他 M 占用，则尝试从全局 空闲 P 列表 中获取一个新的 P。

3. 成功绑定 P 的情况:绑定成功后，M 将继续执行 原本因系统调用阻塞的 G（Goroutine）。G 的状态从 Gsyscall 恢复为 Grunnable，加入 P 的本地队列等待调度。

4. 无法绑定 P 的情况:若所有 P 均被占用，G 会被放回 全局队列（而非本地队列，避免饥饿其他 P）。M 进入休眠状态，加入 空闲 M 列表，等待后续被唤醒（例如新 P 创建或现有 P 释放时）。

## 38.说一下 Gin 的拦截器的原理

## 38.说一下 Gin 的路由怎么实现的

## 39.Gin 的路由使用的数据结构（字典树），介绍一下字典树

## 40.Redis 持久化有几种？

## 41.Redis 的主从架构有哪些

## 42.Go map 为什么是无序的

## 43.MySQL 索引分类，索引的优点和缺点

## 44.分库分表

## 45.Cookie 和 Session 的区别和应用，分布式 Session 的实现

## 46.Redis 的雪崩效应 ，是什么，怎么解决


## 47.map, slice 未初始化，操作会怎么样。


## 48.recover 怎么使用的，defer 相比普通的在函数最后执行操作，其优势是什么

## 49.map 是否并发安全？如何保证并发安全？
map 并发读写都是不安全的。

## 50.如何控制 GMP 中 M 的数量？


## 51. 如何控制 goroutine 的生命周期

## 52.select 如何使用？

## 53.new 和 make 的区别？

## 54.Go string 和 []byte 的区别

## 55.操作系统中零拷贝

## 56.如何排查慢 SQL

## 57.EXPLAIN 执行计划要关注的字段

## 58.如果设置了索引速度还是很慢怎么办

## 59.MySQL 数据量非常大了以后要怎么做

## 60.分库分表有几种思路

## 61.使用 gorm 遇到过哪些坑
_更新时用结构体更新，不会更新零值，需要用 map 数组
_time.Time日期格式默认是 ISO 8601 格式，想要更改格式需要自定义时间结构体

## 62.为什么 MySQL 使用 B+ Tree，Redis 使用跳表？

## 63.虚拟内存的作用？

## 64.Swap 机制是什么？作用是什么？

## 65.线程、进程、协程的区别？

## 66.协程为什么是 2~4kb？

## 67.Go 的 CSP 并发编程介绍一下？

## 68.Go 中的内存逃逸现象是什么？

## 69.tcp、udp的区别？如果让udp变得可靠可以怎么实现？

## 70.5L容器和3L容器怎么倒出4L的水

## 71.golang有哪些优势呢

## 72.切片cap是如何增长的

## 73.redis持久化机制

## 74.select poll epoll 区别

## 75.context的使用

## 76.gin的实现了解过吗

## 77.gin的生命周期

## 78.InnoDB与My-ISAM的区别

## 79.AOF和RDB的区别

## 80.AOF重写是什么

## 81.redis用的多吗？redis单线程为什么性能那么好？

## 82.讲一下redis里的hash槽概念。

## 83.redis集群的主从复制模式是什么样的。

## 84.如何理解redis中的事务

## 85.如何解决缓存雪崩和穿透问题

## 86.redis内存淘汰策略有哪些？

## 87.什么情况下会发生CPU调度？

## 88.什么时候进程会切换？

## 89.进程上下文包括哪些部分？

## 90.什么时候会从用户态切换为内核态？

## 91.进程间通信有哪些？

## 92.项目中使用map有没有遇到一些坑？

## 93.go 语言怎么实现内存对齐的？ 

## 94.Golang内存逃逸？什么情况下会发生内存逃逸？

## 95.常用的加密算法有哪些？应用场景有哪些? 

## 96.读写锁的原理？

## 97.100亿的数据找出前10大的数，内存有限


