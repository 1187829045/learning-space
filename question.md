# 面试题

## 1.如果在CDN中，源站发起了一个更新，如何让远端和近端的人同时拿到更新，而不是拿到旧的缓存？
1. 主动刷新缓存
2. 在资源链接上加入唯一标识参数,然后CDN会视为新资源
3. 预热与监控闭环:更新后提交预热任务，提前将新内容加载至CDN边缘节点，避免首用户访问延迟。


## 2.网络协议的定义是啥，说一说网络协议的三个要素
网络协议是计算机网络中实现数据交换的规则、标准或约定的集合，相当于不同设备间的"通信语言"。它通过统一的交互规则，解决不同终端设备（如计算机、路由器等）在硬件架构、操作系统差异下的互联互通问题。
#### 网络协议三要素 
1. 语义:例如：HTTP协议中状态码200表示请求成功，404代表资源未找到
2. 语法：规定数据传输的结构与格式,数据包头部/尾部字段的二进制排列规则,字符编码标准（如HTTP报文采用UTF-8编码）
3. 时序 : 控制通信流程的顺序与节奏,握手协议（如TCP三次握手建立连接,超时重传机制


## 3.解释一下哈希算法

哈希算法是一种将任意长度输入数据映射为固定长度输出的密码学工具，其核心功能是生成具有唯一性标识的「数字指纹」。
1. 核心特性 :确定性,不可逆性,抗碰撞性,雪崩效应(输入微小变化导致输出显著不同。例如，将"Hello"改为"hello"，其哈希值差异超过90%的二进制位)
2. 以SHA-256为例：将输入数据切分为512位的数据块。使用8个固定32位常数（如6A09E667、BB67AE85等）作为初始哈希值。对每块数据进行64轮逻辑运算（如位运算、模加运算），更新中间哈希值。最终拼接8个中间值得到256位哈希。

## 4.如何设计session
1. 存储截止选型:内存数据库(读写速度快（微秒级响应），支持TTL自动过期),关系型数据库(优势：事务支持强，适合复杂查询场景)
2. 数据结构的话,JSON序列化数据,字段建议：用户ID、登录时间、最后活跃时间、自定义属性


## 5.http和rpc的区别
HTTP 协议与 RPC 的核心区别体现在协议设计目标、性能优化、适用场景三个维度。以下是具体对比分析：

1. 本质定位与协议设计:http是应用层协议,rpc远程调用机制,需通过具体协议（如 gRPC、Dubbo）实现，定义调用方式与流程,http浏览器和服务器的交互,rpc主要是高性能,低延迟
http有固定报文结构（Header+Body），必须遵循规范（如 GET/POST 方法）,rpc可定制协议（如 TCP 私有协议、HTTP/2 二进制封装），支持自定义序列化与压缩.
2. 性能与效率对比:http,文本格式（JSON/XML）为主，体积大，解析慢,rpc二进制协议（Protobuf、Thrift）为主，体积小，编解码效率高
3. 应用场景与功能特性 : http是应用层协议，主要处理客户端与服务器之间的请求和响应，通常用于客户端与服务器之间的通信，如Web请求、文件传输等。而RPC是网络通信协议，主要用于分布式系统之间的通信，通常用于远程过程调用（Remote Procedure Call）等场景。

## 6.两者如何选择

优先选择 HTTP 的场景：
1. 需跨语言、跨平台（如第三方 API 对接）
2. 数据传输以文本为主（如 Web 页面渲染）
3. 对性能要求不敏感（低频调用或小数据量）

优先选择 RPC 的场景：
1. 高并发、低延迟的内部服务通信（如电商订单系统）
2. 需要服务治理能力（如自动熔断、链路追踪）
3. 定制化协议优化（如金融系统要求毫秒级响应）

## 7.如何确保redis同步mysql时，最新的信息不丢失？答了AOF，说AOF在写入前的瞬间挂掉了怎么办？
为确保 Redis 与 MySQL 同步时最新数据不丢失，需从数据更新策略、可靠性传输、持久化机制、异常处理四个维度构建完整解决方案
1. 写操作优先保证数据库一致性:所有写操作 先更新 MySQL，再处理 Redis，避免缓存与数据库的“双写不一致”。Cache-Aside Pattern（旁路缓存模式）
2. 同步机制选择:关键数据：订阅 MySQL Binlog + 同步更新 Redis（如通过 Canal 监听）,普通数据：延迟双删策略（两次删除缓存，间隔主从延迟时间）

## 8.什么是延迟双删

延迟双删是一种用于解决 缓存（如 Redis）与数据库（如 MySQL）数据一致性 问题的策略，尤其在高并发场景下，能有效减少因并发读写导致的数据不一致时间窗口。其核心思想是通过 两次删除缓存并结合延迟等待，确保缓存中的旧数据被彻底清理。
1. 第一次删除缓存,在更新数据库 之前，先删除缓存中的旧数据，确保后续的读请求不会命中旧缓存。
2. 更新数据库,执行数据库写操作（如 SQL 的 UPDATE 或 INSERT）。
3. 延迟等待,等待一个 合理的时间间隔（通常根据 MySQL 主从同步延迟估算，如 500ms~1s），确保数据库主从同步完成。
4. 第二次删除缓存,延迟结束后，再次删除缓存，清除可能因并发读操作重新写入的旧数据。


## 9.什么是binlog和Redo Log,分别的作用是什么
Binlog（二进制日志）和 Redo Log（重做日志）是 MySQL 中两种关键日志机制，分别承担不同功能，共同保障数据库的数据一致性与可靠性.

1. Binlog 是mysql的server层实现的,与存储引擎无关,日志类型：逻辑日志，记录 SQL 语句的原始逻辑（如 UPDATE users SET name='Alice' WHERE id=1;）或行数据变化（ROW 格式）.

**_核心作用_**：主从复制：从库通过重放主库的 binlog 实现数据同步。数据恢复：结合全量备份与 binlog 增量日志，可将数据库恢复到任意时间点。

_写入规则：_ 事务提交时一次性写入（受 sync_binlog 参数控制刷盘策略）。文件以追加方式存储，不会覆盖旧日志（按时间或大小滚动归档）。

_***日志格式：***_ STATEMENT：记录 SQL 原文（可能因函数导致主从不一致）。ROW（推荐）：记录每行数据的变化细节（保证一致性）。MIXED：混合模式，自动选择逻辑或行格式。

2.  Redo Log（重做日志）:由 InnoDB 存储引擎实现，专用于事务的持久性和崩溃恢复,物理日志，记录数据页的物理修改（如页号、偏移量、修改后的值）

**_核心作用：_** 崩溃恢复：系统宕机后，通过重放未刷盘的 redo log 恢复已提交事务的数据。提升性能：采用 WAL（预写日志）机制，事务提交时只需写日志，无需立即刷脏页到磁盘。

**_写入规则：_** 事务执行中实时写入内存（redo log buffer），提交时刷盘（受 innodb_flush_log_at_trx_commit 控制）。固定大小循环写入（默认 ib_logfile0 和 ib_logfile1），覆盖旧日志


## 10.主键索引和普通索引的区别
1. 唯一性:主键索引强制唯一,不允许重复和空置,普通索引允许重复值和空值
2. 数量限制:每个表只能有一个主键索引,可以有多个普通索引
3. 索引类型:主键索引是聚集索引,普通索引是非聚集
4. 自动创建:主键索引会自动创建,需显式通过CREATE INDEX语句或建表时指定
5. 物理存储顺序:数据行按主键值顺序存储，直接影响数据页的物理排列,普通索引,仅索引列按顺序存储，不影响数据行的物理位置
6. 查询效率:主键索引,单次查找，时间复杂度O(logN)，适用于主键精确查询。普通索引：两次查找（普通索引+主键索引），时间复杂度接近2*O(logN)，存在回表开销。
7. 覆盖索引优化:若查询字段全部包含在普通索引中（如联合索引(name, age)查询SELECT name, age），可避免回表，性能接近主键索引。
8. 插入/更新:主键索引:可能触发页分裂（数据页按主键顺序存储，插入中间值需重排数据）,普通索引,仅需更新索引树，不影响数据页物理顺序
9. 删除:主键索引,删除主键行时，需同时清理数据和索引结构	普通索引:仅需删除索引条目，数据行保留（除非级联删除）
10. 存储空间	主键索引:索引与数据合并存储，空间占用更高效	,普通索引：需额外存储主键值（用于回表），空间占用较高
11. 主键索引适用场景,1.需要唯一标识每行数据（如用户ID、订单号）。2.高频通过单一字段查询整行数据的场景（如用户详情页）。3.需要作为外键引用的字段（确保关联查询效率）。
12. 普通索引适用场景,1.高频查询非主键字段（如根据姓名、手机号检索）。2.联合索引优化多条件查询（如(city, age)组合查询）。3.需要允许重复值的字段（如商品分类、标签）。


## 11.多路复用
在计算机系统中，IO多路复用允许单线程管理多个网络连接或文件描述符

1. select/poll：轮询检查文件描述符状态，效率较低。
2. epoll（Linux）：基于事件驱动，仅关注活跃连接，性能更高。


## 12.内核态和用户态的一个区别，为什么设计这两种模式？

1. 核心区别：权限与资源访问能力,内核态:CPU 执行最高特权指令（如 x86 的 Ring 0 级），可直接操作硬件（如磁盘、网卡）、管理内存分配、修改进程调度表等核心资源 ,
用户态:CPU 执行受限指令（如 x86 的 Ring 3 级），无法直接访问硬件或修改系统关键数据。仅能访问进程自身的虚拟内存空间（通过页表隔离），需通过系统调用请求内核服务。
2. 设计原因：安全、稳定与资源管理 ,防止恶意程序破坏系统：若用户程序能直接操作硬件（如修改内存管理单元），可能导致系统崩溃或被恶意攻击（如修改内核代码）。
提升系统稳定性：用户程序可能存在逻辑错误（如空指针访问），若运行在内核态会直接导致系统崩溃。
高效管理硬件资源：内核统一调度 CPU、内存等资源，避免多个程序竞争导致混乱（如两个进程同时写入同一磁盘区域）。



## 13.怎么评估数据库表中一个索引是否创建的合理？
1. 列的离散度（Distinctiveness）,离散度越高，索引筛选效率越高。例如性别字段（仅2种值）离散度低，不适合单独索引；用户ID（唯一值）离散度高，适合索引
2. 高频查询字段:频繁出现在 WHERE、JOIN、ORDER BY、GROUP BY 中的字段优先索引。
3. 避免冗余索引:检查是否存在功能重叠的索引（如已有 (a,b) 联合索引，单独索引 a 可能冗余）。

## 14.解释go中的反射，有什么作用？

1. 反射的基本原理 -接口与类型系统

Go的接口（interface{}）存储了变量的动态类型（_type）和动态值（data），反射通过解析接口的这两部分信息实现动态操作。

空接口（无方法）和有方法的接口均通过类型描述符（_type）和值指针描述数据。

示例：reflect.TypeOf() 获取类型信息，reflect.ValueOf() 获取值信息。

2. 核心类型

reflect.Type：描述类型元信息（如字段、方法、包路径等）。

reflect.Value：封装变量的值，支持修改值、调用方法等操作。

#### 15.反射的核心作用
1. 动态类型检查与操作 :运行时获取变量类型,动态修改变量值

```go
   v := reflect.ValueOf(&x).Elem()
   v.SetInt(42) // 修改 x 的值为 42
```
2. 处理未知类型的数据,用函数与框架：如 fmt.Println 能打印任意类型数据，JSON 序列化库 encoding/json 通过反射解析结构体标签。

3. 动态调用方法：通过 MethodByName() 调用结构体的方法。

4. 适用场景包括框架开发、数据序列化、动态调用等，普通业务逻辑中应谨慎使用。


## 16. 如何设计一个高并发计数器服务，考虑数据一致性，和性能优化？

写流程：客户端 → Redis INCR → Kafka 批量消息 → MySQL 异步落盘（每10秒或积累1000条触发）

读流程：客户端 → Redis 实时值（最新计数） → 降级策略（Redis不可用 → 查询MySQL+补偿）

## 17. 网络I/O的同步和异步的差别

1. 执行逻辑: 同步IO:进程发起I/O请求后必须等待操作完成，期间无法执行其他任务（如调用read()后阻塞）,异步 IO:进程发起I/O请求后立即返回，继续处理后续任务，内核完成操作后通过事件/回调通知
2. 数据阶段:同步IO:包含两个阶段：等待数据就绪（内核态）和拷贝数据到用户空间（用户态），均需等待 异步 IO:内核完成所有操作（包括数据拷贝），仅通过一次通知告知进程结果
3. 时序性:同步IO:严格按请求顺序执行，保证操作原子性,异步IO请求与完成无严格时序关系，可能并发处理多个I/O
4. 资源占用:同步IO:线程/进程在等待期间被挂起，占用内存但CPU闲置,异步IO:仅需少量线程即可处理大量I/O，CPU利用率高


## 18.TCP通过哪些方式实现可靠性
1. 校验和（Checksum）作用：检测数据在传输过程中是否损坏或篡改。
2. 序列号与确认应答（Sequence & ACK）,序列号,确认号
3. 超时重传（Retransmission）
4. 滑动窗口（Sliding Window）
5. 快速重传（Fast Retransmit）
6. 流量控制（Flow Control）
7. 拥塞控制（Congestion Control）
8. 三次握手建立连接
9. 四次挥手释放连接

## 19.内存泄漏原理,怎么排查以及怎么解决


## go的context在高并发下有什么问题


## go的gorm底层是否有线程池，是否有用过


## go的gin框架的特点？还用过什么web框架


## MySQL的事务隔离以及如何实现？


## 超卖过程中，如何利用redis实现高并发？


## 如何实现分布式锁


## 线程池底层，什么场景下使用


## https的Tls rsa握手过程，存在什么安全隐患，分别怎么解决的


## redis的数据类型，zset底层实现的数据结构


## 聚簇索引和非聚簇索引，覆盖索引

## 说一下MVCC

## 什么是协程？


## 为什么有了线程之后还要有协程？


## 进程间的通信

## 共享内存的原理，怎么创建

## 如何优雅地结束一个goroutine

## B树和B+树

## 浏览器输入 URL 的一个过程

## Golang 的 GMP 调度

## M 发生系统调用了 G 和 P 会怎么样

## M 系统调用结束以后会怎么样

## 说一下 Gin 的拦截器的原理

## 说一下 Gin 的路由怎么实现的

## Gin 的路由使用的数据结构（字典树），介绍一下字典树

## Redis 持久化有几种？

## Redis 的主从架构有哪些

## Go map 为什么是无序的

## MySQL 索引分类，索引的优点和缺点

## 分库分表

## Cookie 和 Session 的区别和应用，分布式 Session 的实现

## Redis 的雪崩效应 ，是什么，怎么解决

## slice 和 array 的区别

## map, slice 未初始化，操作会怎么样。发生 panic 应该怎么办

## recover 怎么使用的，defer 相比普通的在函数最后执行操作，其优势是什么

## channel 相关操作

## map 有序无序，为什么？map 是否并发安全？如何保证并发安全？map 并发读写都是不安全的。

如何控制 GMP 中 M 的数量？(???)
如何控制 goroutine 的生命周期，channel 的作用，context 的作用
select 如何使用？
new 和 make 的区别？
Go string 和 []byte 的区别
操作系统中零拷贝
回表是什么
如何减少回表次数来优化
如何排查慢 SQL
如何最直观的查看慢 SQL
EXPLAIN 执行计划要关注的字段
如果设置了索引速度还是很慢怎么办
MySQL 数据量非常大了以后要怎么做
分库分表有几种思路

使用 gorm 遇到过哪些坑
_更新时用结构体更新，不会更新零值，需要用 map 数组
_time.Time日期格式默认是 ISO 8601 格式，想要更改格式需要自定义时间结构体

为什么 MySQL 使用 B+ Tree，Redis 使用跳表？
虚拟内存的作用？
Swap 机制是什么？作用是什么？
通过 Swap 交换的内存比一般磁盘 IO 更快吗？
线程、进程、协程的区别？
协程为什么是 2~4kb？
Go 的 CSP 并发编程介绍一下？
Go 中的内存逃逸现象是什么？
tcp、udp的区别？如果让udp变得可靠可以怎么实现？
5L容器和3L容器怎么倒出4L的水
golang有哪些优势呢
用过select case吗
切片和数组的区别，切片cap是如何增长的
interface的使用
zset的使用场景
redis持久化机制
select poll epoll 区别
context的使用
gin的实现了解过吗
gin的生命周期
InnoDB与My-ISAM的区别
你理解的索引
你说你最常用的数据类型是string，那你了解过它底层怎么实现的么
AOF和RDB的区别
AOF重写是什么
redis用的多吗？redis单线程为什么性能那么好？
讲一下redis里的hash槽概念。
redis集群的主从复制模式是什么样的。
如何理解redis中的事务
如何解决缓存雪崩和穿透问题
redis内存淘汰策略有哪些？
什么情况下会发生CPU调度？
什么时候进程会切换？
进程上下文包括哪些部分？
什么时候会从用户态切换为内核态？
进程间通信有哪些？
项目中使用map有没有遇到一些坑？
go语言怎么实现内存对齐的？ 不会
Golang内存逃逸？什么情况下会发生内存逃逸？吟唱
常用的加密算法有哪些？应用场景有哪些? 不熟
读写锁的原理？
100亿的数据找出前10大的数，内存有限


